#CLASS {cRoomScan} {kill};
#CLASS {cRoomScan} {open};
#NOP **** Variables ****

#VAR {room} {};

#VAR {RoomScan[mob]} 
{
  {under the control of}{-1}
  {the skeleton}{-1}
  {the zombie}{-1}
  {the valpur}{-1}
  {the ghast}{-1}
  {the manshi}{-1}
  {the bolwyn}{-1}
  {the greesh}{-1}
  {the wight}{-1}
  {the heucuva}{-1}
  {the tholen}{-1}
  {the bayen}{-1}
  {the quarin}{-1}
  {the mohrg}{-1}
  {the grimare}{-1}
  {the valithyn}{-1}
  {esquire}{-1}
  {'s}{-1}
};

#VAR {RoomScan[objects]} 
{ 
  {coins}{1}
  {phial}{1}
  {bag}{1}
  {fragment of}{1}
  {essence of}{1}
  {heart of}{1}
  {puppy}{1}
  {black stone}{-1}
  {grafting}{-1}
  {departing}{-1}
  {devouring}{-1}
  {slow digestion}{-1}
  {quick digestion}{-1}
  {hunger}{-1}
  {fractures}{-1}
  {nullification}{-1}
  {obliquity}{-1}
  {fumbling}{-1}
  {fear}{-1}
  {departing}{-1}
  {empty}{-1}
  {-\d.}{-1}  
};

#NOP **** Substitutions ****;
#NOP ** All flagged objects
#NOP #SUBSTITUTE {<%w`} {};
#NOP #SUBSTITUTE {`>} {};

#NOP **** Triggers ****
#NOP ** brief no map

#NOP ** brief/verbose with map
#NOP #ACTION {{^(\S.{68})[?:\@|\+|\^|v|E].*}}
{
	#REGEXP {%1} {{(.*) \(([a-z,]*)\).*$}}
	{
		#VAR {room} {};
		#VAR {room[name]} {&2};
		#NOP handler_parse_room_exits {&3};
    event_raise {e_room_header};
	};
} {2};

#NOP *********** Aliases **************;

#ALIAS {handler_room_contents}
{
  #NOP %1;
  #LIST {temp[tokenized]} {create} {%2};
  #VAR {temp[item][id]} {$temp[tokenized][2]};
  #VAR {temp[item][name]} {$temp[tokenized][3]};
  #REPLACE {temp[tokenized][4]} {/} {;};
  #REPLACE {temp[tokenized][4]} {#N} {$temp[tokenized][2]};
  #LIST {temp[item][actions]} {create} {$temp[tokenized][4]};
  #LIST {room[contents][$temp[tokenized][1]]} {add} {{$temp[item]}};
  event_raise e_room_${temp[tokenized][1]} {$temp[item][id]} {$temp[item][name]} {$temp[item][actions]};
};
event_register e_mip_HAA h_room_contents handler_room_contents;
event_register e_mip_HAB h_room_contents handler_room_contents;

#ALIAS {handler_room_end}
{
  #NOP %1;
  #IF {&room[contents][player][] <= 0}
  {
    #IF {$auto[kill][status] > 0 && &room[contents][npc][] > 0}
    {
      handler_autokill;
    };
    #IF {"&RoomScan[commandqueue][1]" != "0"}
    {
      #FORALL {$RoomScan[commandqueue][%*]} 
      {
        #SEND {&0};
      };
      #UNVAR {RoomScan[commandqueue]};
    };
    #IF {"$RoomScan[autokill_combat]" != "1"}
    {
      event_raise e_roomscan_finished;
    };
  }
  {
    event_raise e_roomscan_finished;
  };
};

#ALIAS {.HandlerRoomExits}
{
  #NOP %1;
  #IF {"$mip[last]" != "BAD"}
  {
    #VAR {room} {};
    #VAR {room[exits]} {%2};
    event_oneshot e_prompt h_room_end handler_room_end;
    event_raise {e_room_enter} {%2};
  };
};
event_register {e_mip_DDD} {h_room_exits} {.HandlerRoomExits};

#ALIAS {.HandlerRoomName}
{
  #NOP %1;
  #REGEXP {%2} {{^(.*?)\s*\([a-z,]*\)$}}
  {
    #VAR {room[name]} {&2};
  }
  {
    #VAR {room[name]} {%2};
  };
};
event_register {e_mip_BAD} {h_room_name} {.HandlerRoomName};
event_register {e_ansiflags_R} {h_room_name} {.HandlerRoomName};

#ALIAS {handler_room_pickup}
{
  #NOP %1;

  #FORALL {$RoomScan[objects][]}
  {
    #IF {"$RoomScan[break]" != "1"}
    {
      #REGEXP {%3} {\b&0\b}
      {
        #IF {"$RoomScan[objects][&0]" == "-1"}
        {
          #UNVAR {RoomScan[commandbuffer]};
          #VAR {RoomScan[break]} {1};
        }
        {
          #IF {"$RoomScan[objects][&0]" == "1"}
          {
            #VAR {RoomScan[commandbuffer]} {get %2};
          }
          {
            #VAR {RoomScan[commandbuffer]} {$RoomScan[objects][&0]};
          };
        };
      };
    };
  };
  
  #IF {"$RoomScan[commandbuffer]" != ""}
  {
    #LIST {RoomScan[commandqueue]} {add} {$RoomScan[commandbuffer]};
  };
  #ELSEIF {"$RoomScan[break]" != "1" && "$flags[autopickup]" == "2"}
  {
    #LIST {RoomScan[commandqueue]} {add} {get %2};
  };
  
  #UNVAR {RoomScan[break]};
  #UNVAR {RoomScan[commandbuffer]};
};

#ALIAS {autopickup}
{
  #IF {"%1" == "off" || "%1" == "stop"}
  {
    #VAR {flags[autopickup]} {0};
    #ECHO {Auto Pickup Off};
    #RETURN;
  };
  #IF {"%1" == "min"} {#VAR {flags[autopickup]} {0};};
  #IF {"%1" == "full"} {#VAR {flags[autopickup]} {1};};

  #SWITCH {"$flags[autopickup]"}
  {
    #CASE {"0"}
    {
      #VAR {flags[autopickup]} {1};
      #ECHO {Auto Pickup Minimal};
    }
    #CASE {"1"}
    {
      #VAR {flags[autopickup]} {2};
      #ECHO {Auto Pickup Full};
    };
    #CASE {"2"}
    {
      #VAR {flags[autopickup]} {1};
      #ECHO {Auto Pickup Minimal};
    };
  };

  #IF {$flags[autopickup] > 0 }
  {
    event_register e_room_item h_auto_pickup handler_room_pickup;
  };
  #ELSE
  {
    event_remove_handler h_auto_pickup;
  };
};

autopickup min;

#ALIAS {handler_autokill}
{
  #NOP %1;
  #IF {$mip[FFF][N][data] > 0}
  {
    #VAR {flags[autopause]} {1};
    #VAR {RoomScan[autokill_combat]} {1};
    event_oneshot e_killed_opponent h_autokill_finish handler_autokill_finish;
    #BREAK;
  };

  #IF {"$RoomScan[autokill_combat]" != "1"}
  {
    #FOREACH {$room[contents][npc][]} {i}
    {
      #VAR {RoomScan[current]} {$room[contents][npc][$i]};
      #FORALL {$RoomScan[mob][]}
      {
        #IF {"$RoomScan[break]" != "1"}
        {
          #REGEXP {$RoomScan[current][name]} {\b&0\b}
          {
            #IF {"$RoomScan[mob][&0]" == "-1"}
            {
              #UNVAR {RoomScan[commandbuffer]};
              #VAR {RoomScan[break]} {1};
            }
            {
              #IF {"$RoomScan[mob][&0]" == "1"}
              {
                #VAR {RoomScan[commandbuffer]} {kill $RoomScan[current][id]};
              };
            };
          };
        };
      };
      #IF {"$RoomScan[break]" != "1" && "$RoomScan[commandbuffer]" == "" }
      {
        #VAR {RoomScan[target]} {$RoomScan[current][id]};
      };
    };
    #IF {"$RoomScan[commandbuffer]" != ""}
    {
      #VAR {flags[autopause]} {1};
      #VAR {RoomScan[autokill_combat]} {1};
      event_oneshot e_killed_opponent h_autokill_finish handler_autokill_finish;
      #LIST {RoomScan[commandqueue]} {add} {$RoomScan[commandbuffer]};
    };
    #ELSEIF {"$RoomScan[target]" != ""}
    {
      .aYesNo {Kill $RoomScan[target]}
      {
        #SEND {!kill $RoomScan[target]};
        #VAR {RoomScan[autokill_combat]} {1};
        #VAR {flags[autopause]} {1};             
        event_oneshot e_killed_opponent h_autokill_finish handler_autokill_finish;
      }
      {
        #VAR {flags[autopause]} {0};
        #VAR {RoomScan[autokill_combat]} {0};
        handler_autokill_finish;
        event_raise e_roomscan_finished;
      };
      #VAR {flags[autopause]} {1};
      #VAR {RoomScan[autokill_combat]} {1};
    };
    #ELSE
    {
      handler_autokill_finish;
      event_raise e_roomscan_finished;
    };
  };
  #UNVAR {RoomScan[break]};
  #UNVAR {RoomScan[target]};
  #UNVAR {RoomScan[current]};
  #UNVAR {RoomScan[commandbuffer]};
};

#ALIAS {handler_autokill_finish}
{
  #NOP %1;
  #VAR {RoomScan[autokill_combat]} {0};
};

#CLASS {cRoomScan} {close};
